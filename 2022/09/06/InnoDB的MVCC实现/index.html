<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Bruce Yao">





<title>InnoDB 的 MVCC 实现 | Yao&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Yao&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">Home</a>
                
                    <a class="menu-item" href="/archives">Archives</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About Me</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Yao&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/">Home</a>
                
                    <a class="menu-item" href="/archives">Archives</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About Me</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">InnoDB 的 MVCC 实现</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Bruce Yao&nbsp;</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 6, 2022&nbsp;&nbsp;15:45:07&nbsp;</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在数据库的四种隔离级别和三种异常中，读已提交可以解决脏读的异常，可重复读可以解决不可重复的的异常，串行化可以解决幻读的问题，但是串行化的方式会将数据库的事务并发程度降到最低。MVCC 是一种利用乐观锁的想法，不采用锁机制来解决不可重复读和幻读问题。它在大多数情况下可以替代行级锁同时降低系统的开销。</p>
<img src="/2022/09/06/InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0/1647232640212-2b535fcc-8dbb-4654-b48f-63b523f91d0a.png" alt="image.png" style="zoom:67%;">

<h2 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h2><h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>快照读读取的是记录的可见版本（可能是历史数据）。InnoDB 执行<code>select</code>时，默认使用快照读，也可以说未加锁的<code>SELECT</code>都属于快照读。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure>
<p>假设事务 B 执行<code>insert</code>提交后，事务A执行了<code>select</code>，那么返回的数据中就会有事务 B 添加的那条数据，之后无论其他事务是否提交或者修改数据，<code>select</code>语句查找的数据都不会改变。</p>
<p>再假设事务 A 的逻辑是：if sex &#x3D; ‘男’，执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tb_user <span class="keyword">SET</span> type <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>如果在事务 A 没有 commit 之前，事务 B 修改了性别，因为读取的是快照信息，就仍然会执行上述语句。快照读这时就会出现问题。</p>
<h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>当前读就是读取最新的数据。MVCC 中的增删改查（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>）需要加锁操作，都属于当前读。其中<code>SELECT</code>可以加锁或者不加锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>;</span><br><span class="line"><span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">DELETE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SELECT可以强制加锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? lock <span class="keyword">in</span> share mode; <span class="comment">/* 加S锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">/* 加X锁 */</span></span><br></pre></td></tr></table></figure>
<p>例如使用<code>SELECT * FROM able WHERE ? for update;</code>当前读每次读的数据就可能不相同而出现幻读问题，会查询到其他事务<code>insert</code>的数据。</p>
<h2 id="一致性非锁定读和锁定读"><a href="#一致性非锁定读和锁定读" class="headerlink" title="一致性非锁定读和锁定读"></a>一致性非锁定读和锁定读</h2><h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>一致性非锁定读指的是如果要读取的行记录被加 X 锁，读取操作不会等待行记录上的锁释放，而是会读取行的最新快照数据。InnoDB 在 RC 和 RR 两种隔离级别中会使用一致性非锁定读，但是这两种隔离级别对于读取的快照数据不相同：</p>
<ul>
<li>RC：总是读取行记录的最新版本。如果行被加锁，不会等待锁的释放，而是回去读取行记录的最新快照记录；</li>
<li>RR：总是读取事务开始时的快照数据版本；</li>
</ul>
<h3 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h3><p>通过加锁保证数据逻辑的一致性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对于读取的行记录加X锁，其他事务不能对行加任何锁 */</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对于读取的行记录添加一个 S 共享锁。其它事务可以向被锁定的行加 S 锁，但是不允许添加 X 锁，否则会被阻塞住 */</span></span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>一致性非锁定读的情况下其他事务仍然可以读取数据，极大地提高了数据库的并发性。</li>
<li>一致性锁定读适用于对数据一致性要求比较高的情况，需要我们对读操作进行加锁从而保证数据逻辑的一致性。</li>
</ul>
<h2 id="InnoDB中的MVCC"><a href="#InnoDB中的MVCC" class="headerlink" title="InnoDB中的MVCC"></a>InnoDB中的MVCC</h2><p>MVCC（Multiversion Concurrency Control）通过数据行的多个版本管理来实现数据库的并发控制，主要思想为保存数据的历史版本，通过事务的ID来判断数据是否显示，读取数据时不需要加锁同时可以保证事务的隔离等级。InnoDB 主要通过 Undo Log 和 Read View 来实现 MVCC。</p>
<h3 id="事务ID和隐藏列"><a href="#事务ID和隐藏列" class="headerlink" title="事务ID和隐藏列"></a>事务ID和隐藏列</h3><p>在数据库中每开启一个事务，该事务就会有一个事务版本号。事务版本号是<strong>自增长</strong>的，通过事务 ID 的大小，我们可以判断事务的时间顺序。</p>
<p>InnoDB的行记录中存储了重要的隐藏字段，其中包括了行 ID、事务 ID 和回滚指针。行记录中存储的事务 ID 为最后一个对该数据进行修改更新的事务 ID。回滚指针就是指向这个记录的 Undo Log 信息。<br><img src="/2022/09/06/InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0/1646809203314-319d2183-5ca1-4a93-8d89-6af67d7a36d0.png" alt="image.png"></p>
<h3 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h3><p>InnoDB 将行记录保存在了 Undo Log 中，我们可以通过回滚指针来找到它们，回滚指针将数据行的所有快照记录通过链表的数据结构类型串联起来。同样，每个快照都保存了当时修改该记录的事务 ID。<br><img src="/2022/09/06/InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0/1646810470838-33da9985-2d46-4c56-b038-68f988a62bac.png" alt="image.png" style="zoom:67%;"></p>
<h3 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h3><p>Read View中保存了当前事务开始时所有活跃（未提交）的事务列表。Read View包含了四个重要属性：</p>
<ul>
<li><strong>trx_ids：</strong>系统当前正在活跃的事务 ID 集合。</li>
<li><strong>up_limit_id：</strong>活跃的事务中最大的事务 ID。</li>
<li><strong>low_limit_id：</strong>活跃的事务中最小的事务 ID。</li>
<li><strong>creator_trx_idL：</strong>创建这个 Read View 的事务 ID。</li>
</ul>
<p><img src="/2022/09/06/InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0/1646810049005-e20c4b31-6d4a-4cb6-aeac-6524f5afda67.png" alt="image.png"></p>
<p>如果当前事务creator_trx_id要读取某个行记录，需要和该行记录的事务ID（trx_id）比较，出现的所有情况如下：</p>
<ol>
<li><strong>trx_id &lt; low_limit_id：</strong>说明修改该行记录的事务在当前活跃事务创建之前就已经提交，所以该行记录对事务creator_trx_id是可见。</li>
<li><strong>trx_id &gt; up_limit_id：</strong>说明修改该行记录的事务在当前活跃事务创建之后才能提交，所以该行记录对事务creator_trx_id不可见。</li>
<li><strong>low_limit_id &lt; trx_id &lt; up_limit_id：</strong>说明修改该行记录的事务可能在当前事务创建时还处于活跃的状态。此时在trx_ids中遍历，如果tri_id在tri_ids中，说明进行修改的事务还处于活跃的状态，所以该行记录不可见。如果tri_id不在tri_ids中，说明进行修改的事务已经提交，该行记录因此可见。</li>
</ol>
<h3 id="MVCC的流程"><a href="#MVCC的流程" class="headerlink" title="MVCC的流程"></a>MVCC的流程</h3><ol>
<li>获取当前事务的 ID；</li>
<li>获取 Read View；</li>
<li>查询得到的数据，然后与 Read View 中的事务版本号进行比较；</li>
<li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li>
<li>最后返回符合规则的数据。</li>
</ol>
<p><strong>RC：</strong>事务中的一次<code>select</code>会获取一次  Read View。如果两次<code>select</code>的 Read View不同时，会发生不可重复读或者幻读的异常。</p>
<img src="/2022/09/06/InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0/1646811699871-ddd8ff79-3c5f-4d29-acbb-6accb66896d2.png" alt="image.png" style="zoom:67%;">

<p><strong>RR：</strong>事务只在第一次<code>select</code>获取 Read View，之后的事务中所有<code>select</code>都会重复使用该 Read View。<br><img src="/2022/09/06/InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0/1646811703914-18752bd3-59dc-4d7e-96ca-4eeac1d2110d.png" alt="image.png" style="zoom:67%;"></p>
<h2 id="MVCC解决幻读"><a href="#MVCC解决幻读" class="headerlink" title="MVCC解决幻读"></a>MVCC解决幻读</h2><p>InnoDB中的行锁有三种方式：</p>
<ol>
<li><p><strong>Record Lock：</strong>记录锁，针对单个行记录添加锁。</p>
</li>
<li><p><strong>Gap Lock：</strong>间隙锁，可以帮我们锁住一个范围（索引之间的空隙），但不包括记录本身。采用间隙锁的方式可以防止幻读情况的产生。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 其他事务不能在t.c中插入15 */</span></span><br><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Next-Key Lock：</strong>帮我们锁住一个范围（左必右开），同时锁定记录本身，相当于间隙锁 + 记录锁。该锁主要用来解决幻读的问题。例如范围中包含 10, 11, 13, 20，那么就需要锁定一些区间：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="operator">-</span>∞, <span class="number">10</span>]</span><br><span class="line">(<span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">(<span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">(<span class="number">13</span>, <span class="number">20</span>]</span><br><span class="line">(<span class="number">20</span>, <span class="operator">+</span>∞)</span><br></pre></td></tr></table></figure>
<p>在隔离级别为 RR 时，InnoDB 会采用 Next-Key 锁机制解决幻读问题。仅使用 MVCC 不能解决幻读的异常，在两次读取中仍可以插入记录行，而 Next-Key 锁会锁定一个范围，其他的事务无法插入在该范围内的记录行：</p>
</li>
</ol>
<img src="/2022/09/06/InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0/1646811868300-73638ec6-8043-4bc2-b504-fa88c1bfb54b.png" alt="image.png" style="zoom:67%;">

<img src="/2022/09/06/InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0/1646811873902-7fc0ec40-4cb0-429e-8104-3eb5059cdd0b.png" alt="image.png" style="zoom: 45%;">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVCC 的核心就是 Undo Log+ Read View，“MV”就是通过 Undo Log 来保存数据的历史版本，实现多版本的管理，“CC”是通过 Read View 来实现管理，通过 Read View 原则来决定数据是否显示。同时针对不同的隔离级别，Read View 的生成策略不同，也就实现了不同的隔离级别。</p>
<p>MVCC主要解决了三种问题：</p>
<ul>
<li>读写之间的阻塞问题</li>
<li>降低了死锁的概率</li>
<li>解决一致性问题</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/27352449bcc0">当前读与快照读-简书</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6870018522932576270">当前读与快照读-掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/randompeople/article/details/115721073">mysql MVCC不能避免幻读</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cswiki/p/15307265.html">一致性非锁定锁读和一致性锁定读</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/n/a7414656529f4726a9a11dffac9ab7cf?from=nowcoder_improve">Mysql的一致性锁定读和一致性非锁定</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhoujinyi/p/3435982.html">Innodb锁机制：Next-Key Lock 浅谈</a></li>
</ol>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/09/06/%E5%8F%8C%E6%8C%87%E9%92%88/">双指针</a>
            
            
            <a class="next" rel="next" href="/2022/09/06/MySQL%E7%B4%A2%E5%BC%95%E7%A7%8D%E7%B1%BB%E5%8F%8A%E4%BC%98%E5%8C%96/">MySQL 索引种类及优化</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Bruce Yao | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>