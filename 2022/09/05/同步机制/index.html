<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Bruce Yao">





<title>同步机制 | Yao&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Yao&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">Home</a>
                
                    <a class="menu-item" href="/archives">Archives</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About Me</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Yao&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/">Home</a>
                
                    <a class="menu-item" href="/archives">Archives</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About Me</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">同步机制</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Bruce Yao&nbsp;</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 5, 2022&nbsp;&nbsp;16:48:55&nbsp;</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><p>由于各个进程要求使用共享资源（变量、文件等），而这些资源需要排他性使用，各个进程之间竞争使用这些资源，这一关系被称为进程互斥。</p>
<h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>系统中的某些资源一次只允许一个进程使用，称这些资源为临界资源或这互斥资源或共享资源。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>每个进程中对某个临界资源（共享变量）实施操作的程序片段。</p>
<h3 id="临界区（互斥区）的使用原则"><a href="#临界区（互斥区）的使用原则" class="headerlink" title="临界区（互斥区）的使用原则"></a>临界区（互斥区）的使用原则</h3><ul>
<li>没有进程在临界区时，想进入临界区的进程可以进去；</li>
<li>不允许两个进程同时处于它们的临界区；</li>
<li>临界区外运行的进程不得阻塞其他进程进入临界区；</li>
<li>不得是进程无限期等待进去临界区；</li>
</ul>
<h2 id="进程互斥的软件解决方法"><a href="#进程互斥的软件解决方法" class="headerlink" title="进程互斥的软件解决方法"></a>进程互斥的软件解决方法</h2><h3 id="错误解法"><a href="#错误解法" class="headerlink" title="错误解法"></a>错误解法</h3><p>考虑两个进程 p 和 q，pturn 与 qturn 表示对应的进程进入临界区。</p>
<ul>
<li>p 进入临界区的条件：pturn &amp;&amp; not qturn；</li>
<li>q 进入临界区的条件：not pturn &amp;&amp; qturn；<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 进程p：</span><br><span class="line">pturn = true;     </span><br><span class="line">while (qturn);          </span><br><span class="line">visit();	//访问临界区</span><br><span class="line">pturn = false;</span><br><span class="line"></span><br><span class="line">// 进程q：</span><br><span class="line">qturn = true;     </span><br><span class="line">while (pturn) ;          </span><br><span class="line">visit();   	//访问临界区</span><br><span class="line">qturn = false;</span><br></pre></td></tr></table></figure>
如果由于 CPU 调度使得两个进程全部都执行第一行语句，即 pturn 和 qturn 都为 true，那么在下一行 while 语句上，两个进程都会死循环，都在谦让对方，这样不满足不能使进程无限期等待进入临界区的原则。</li>
</ul>
<h3 id="Dekker-算法"><a href="#Dekker-算法" class="headerlink" title="Dekker 算法"></a>Dekker 算法</h3><p>同样假设有两个进程 p 和 q，变量 pturn 和 qturn 分别表示这两个进程是否想要进入临界区，为了解决进程无限期等待的问题，Dekker 算法加入了一个变量 turn 决定两个进程相互等待的时候谁进入临界区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程p：</span></span><br><span class="line">pturn = <span class="literal">true</span>; 	<span class="comment">// 进程p举手示意想要访问</span></span><br><span class="line"><span class="keyword">while</span> (qturn) &#123; 	<span class="comment">// 如果进程q也举手了</span></span><br><span class="line">    <span class="keyword">if</span> (turn == <span class="number">2</span>) &#123;   <span class="comment">// 资源被安排给了q</span></span><br><span class="line">        pturn = <span class="literal">false</span>;   <span class="comment">// 进程p把手放下</span></span><br><span class="line">        <span class="keyword">while</span> (turn == <span class="number">2</span>);   <span class="comment">// 资源安排给q的时候一直等待</span></span><br><span class="line">        pturn = <span class="literal">true</span>;    <span class="comment">// 此时资源安排给了自己，进程p再举手</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">visit();	<span class="comment">// 访问临界区</span></span><br><span class="line">turn = <span class="number">2</span>;   <span class="comment">// 进程p使用完了，安排资源给q</span></span><br><span class="line">pturn = <span class="literal">false</span>;	<span class="comment">// 进程p把手放下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程q：</span></span><br><span class="line">qturn = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">while</span> (pturn) &#123; </span><br><span class="line">    <span class="keyword">if</span> (turn == <span class="number">1</span>) &#123; </span><br><span class="line">        qturn = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">while</span> (turn == <span class="number">1</span>); </span><br><span class="line">        qturn = <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">visit();	<span class="comment">// 访问临界区</span></span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">qturn = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>如果两个进程都执行完了第一行语句，也就是 pturn 和 qturn 都为true了，那么会根据变量 turn 进一步确定将资源安排给谁，如果安排给了另一个进程，那么当前进程就将自己的手放下，然后等待安排资源给自己。</p>
<p>和上一种错误解法相比，可以发现 Dekker 算法就是在原本的 while 循环前做了进一步的判断，引入的 turn 变量总是会安排一个进程进入到临界区。但是当其他进程不能上 CPU时，while 循环的测试实际上就在浪费时间，这就是强制轮流，是 Dekker 算法的一个缺陷。</p>
<h3 id="Peterson-算法"><a href="#Peterson-算法" class="headerlink" title="Peterson 算法"></a>Peterson 算法</h3><p>Peterson 算法克服了强制轮流的缺点，可以正常解决并发进程互斥与同步。在进程出入临界区时，只需要使用两个函数即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enter_region(i);</span><br><span class="line">visit();	<span class="comment">// 访问临界区</span></span><br><span class="line">leave_region(i);</span><br></pre></td></tr></table></figure>
<p>其中 enter_region 和 leave_region 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define FALSE <span class="number">0</span></span><br><span class="line">#define TRUE <span class="number">1</span></span><br><span class="line">#define N <span class="number">2</span> <span class="comment">// 进程的个数</span></span><br><span class="line"><span class="type">int</span> turn;   <span class="comment">// 轮到谁</span></span><br><span class="line"><span class="type">int</span> interested[N];   <span class="comment">// 兴趣数组，初始值均为FALSE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">enter_region</span><span class="params">(<span class="type">int</span> process)</span> <span class="comment">// process = 0 或 1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> other;     <span class="comment">// 另外一个进程的进程号</span></span><br><span class="line">    other = <span class="number">1</span> - process;</span><br><span class="line">    interested[process] = TRUE;  <span class="comment">// 表明本进程感兴趣</span></span><br><span class="line">    turn = process;  <span class="comment">// 设置标志位         </span></span><br><span class="line">    <span class="keyword">while</span>(turn == process &amp;&amp; interested[other] == TRUE); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">leave_region</span><span class="params">(<span class="type">int</span> process)</span>&#123;</span><br><span class="line">	interested[process] = FALSE;   <span class="comment">// 本进程已离开临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有两个进程都要进入临界区，turn 会被设置为最后一个进程的进程号，按照先来后到的规定，后一个进程 while 中的 turn&#x3D;&#x3D;process 成立，然后进入循环等待，这个时候先到的进程可以进入临界区。当先进入的进程离开了临界区执行了 leave_region 方法后，后到进程 while 循环中 interested[other]&#x3D;&#x3D;TRUE 条件被打破，这个进程就可以跳出循环等待然后进入到它的临界区。</p>
<h2 id="进程互斥的硬件解法"><a href="#进程互斥的硬件解法" class="headerlink" title="进程互斥的硬件解法"></a>进程互斥的硬件解法</h2><h3 id="TSL-指令"><a href="#TSL-指令" class="headerlink" title="TSL 指令"></a>TSL 指令</h3><blockquote>
<p>TSL，TEST AND SET LOCK，测试并加锁</p>
</blockquote>
<p>TSL 将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存储一个非零值。读写指令能保证是一体的，不可分割的，一同执行的。在这个指令结束之前其他处理器均不允许访问内存。执行 TSL 指令的 CPU 会锁住内存总线，用来禁止其他 CPU 在这个指令结束之前访问内存。</p>
<p>锁住内存总线和屏蔽中断是不一样的：屏蔽中断并不能保证一个处理器在读写操作期间另一个处理器对内存的读写，而锁住内存总线可以做到屏蔽另一个处理器的影响。</p>
<p>为了使用 TSL 指令，要使用一个共享变量 LOCK 来协调对共享内存的访问。当 LOCK 为 0 时，任何进程都可以使用 TSL 指令将其设置为 1，并读写共享内存。当操作结束时，内存使用 MOVE 指令将 LOCK 重新设置为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">TSL REGISTER,LOCK       <span class="comment">// 复制锁到寄存器然后将锁设为1</span></span><br><span class="line">    CMP REGISTER,#<span class="number">0</span>     <span class="comment">// 锁是0吗？</span></span><br><span class="line">    JNE enter_region    <span class="comment">// 若不是0，说明锁已被设置，所以循环</span></span><br><span class="line">    RET                 <span class="comment">// 返回调用者，进入了临界区</span></span><br><span class="line"></span><br><span class="line">leave_region:</span><br><span class="line">MOVE LOCK,#<span class="number">0</span>            <span class="comment">// 在锁中存入0</span></span><br><span class="line">    RET                 <span class="comment">// 返回调用者</span></span><br></pre></td></tr></table></figure>
<h3 id="XCHG-指令"><a href="#XCHG-指令" class="headerlink" title="XCHG 指令"></a>XCHG 指令</h3><p>XCHG 原子性的交换了两个位置的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">MOVE REGISTER,#<span class="number">1</span>        	<span class="comment">// 在寄存器中放一个1</span></span><br><span class="line">    XCHG REGISTER,LOCK      <span class="comment">// 交换寄存器与锁变量的内容</span></span><br><span class="line">    CMP REGISTER,#<span class="number">0</span>         <span class="comment">// 锁是0吗？</span></span><br><span class="line">    JNE enter_region        <span class="comment">// 若不是0，说明锁已被设置，所以循环</span></span><br><span class="line">    RET                     <span class="comment">// 返回调用者，进入了临界区</span></span><br><span class="line"></span><br><span class="line">leave_region:</span><br><span class="line">MOVE LOCK,#<span class="number">0</span>            	<span class="comment">// 在锁中存入0</span></span><br><span class="line">    RET                     <span class="comment">// 返回调用者</span></span><br></pre></td></tr></table></figure>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>在 TSL 和 XCHG 中都使用了锁机制，锁是一个代表共享资源状态的变量：</p>
<ul>
<li>0 表示资源没有被占用，开锁状态</li>
<li>1 表示资源已被占用，加锁状态</li>
</ul>
<p>在使用临界资源前需先考察锁变量的值，如果值为 0 则将锁设置为 1（加锁），如果值为 1 则重新考察锁变量的值。当进程使用完资源后，应将锁设置为 0（开锁）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上锁</span></span><br><span class="line">lock（w）</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">while</span>（w==<span class="number">1</span>）；</span><br><span class="line">    w = <span class="number">1</span>；</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 开锁</span></span><br><span class="line">unlock（w）</span><br><span class="line"> &#123; </span><br><span class="line">     w = <span class="number">0</span>；</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 锁机制实现互斥</span></span><br><span class="line">进程P1             进程P2</span><br><span class="line">   ┆                ┆</span><br><span class="line"> lock(w)；         lock(w)；</span><br><span class="line"> 临界区；           临界区；</span><br><span class="line"> unlock(w)；       unlock(w)；</span><br><span class="line">   ┆                ┆</span><br></pre></td></tr></table></figure>
<h2 id="忙等待-amp-amp-自旋锁"><a href="#忙等待-amp-amp-自旋锁" class="headerlink" title="忙等待 &amp;&amp; 自旋锁"></a>忙等待 &amp;&amp; 自旋锁</h2><ul>
<li><p>忙等待（busy waiting）：在软件解决方法和硬件解决方法中，我们使用 while 循环测试是否开锁或者条件是否成立，导致等待进程在允许进入临界区之前会循环测试而浪费CPU的周期。</p>
</li>
<li><p>自旋锁（spin lock）：在多处理器的情况下，系统允许一个进程在某一个 CPU 上循环测试。如果当前进程想要进入临界区同时有其他的进程位于临界区，那么该进程就不断自旋、测试，直到临界区释放。</p>
</li>
<li><p>自旋锁是忙等待在多处理器情况下的演变，本质还是循环测试直到进程允许进入临界区。</p>
</li>
</ul>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程同步指系统中多个进程中发生的事件存在某种时序关系，需要相互合作，共同完成一项任务。具体地说，一个进程运行到某一点时， 要求一个伙伴进程为它提供消息，在未获得消息之前，该进程进入阻塞态，获得消息后被唤醒进入就绪态。</p>
<h2 id="信号量及-PV-操作"><a href="#信号量及-PV-操作" class="headerlink" title="信号量及 PV 操作"></a>信号量及 PV 操作</h2><p>信号量是一个特殊的变量，用于进程之间专递信息的一个整数值，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct semaphore</span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> count;			<span class="comment">// 用来进程之间传递的整数值</span></span><br><span class="line">	queueType queue;	<span class="comment">// 进程可以挂在信号量所属的队列上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以对信号量进行初始化（非负数）、P（down）和 V（up）操作，PV 操作均为原语操作。定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">P(semaphore s) </span><br><span class="line">&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span> (s.count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//该进程状态置为阻塞状态；</span></span><br><span class="line">        <span class="comment">//将该进程插入相应的等待队列s.queue末尾;</span></span><br><span class="line">        <span class="comment">//重新调度；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(semaphore s) &#123;   </span><br><span class="line">    s.count++;   </span><br><span class="line">    <span class="keyword">if</span> (s.count &lt;= <span class="number">0</span>)   </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="comment">//唤醒相应等待队列s.queue中等待的一个进程；      </span></span><br><span class="line">        <span class="comment">//改变其状态为就绪态，并将其插入就绪队列；    </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>信号量的取值为二值（0 &#x2F; 1），那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。</li>
<li>多值信号量则用来解决进程之间的同步问题。</li>
</ul>
<h2 id="用-PV-操作解决进程之间的互斥问题"><a href="#用-PV-操作解决进程之间的互斥问题" class="headerlink" title="用 PV 操作解决进程之间的互斥问题"></a>用 PV 操作解决进程之间的互斥问题</h2><ul>
<li>分析并发进程的关键活动，划定临界区；</li>
<li>设计信号量 mutex，初始值为 1；</li>
<li>在进入临界区之前实施 P(mutex)；</li>
<li>在离开临界区之后实施 V(mutex)；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2323967/1648889184362-689802f6-e8fd-429c-a4f9-11a0c78b6c53.png#clientId=u4c1059ba-7a84-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u8f499af8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=436&originWidth=1300&originalType=binary&ratio=1&rotation=0&showTitle=false&size=662452&status=done&style=none&taskId=u0e118c77-4280-4258-b192-05d2603c6ea&title=&width=650" alt="image.png"></p>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>生产者-消费者问题又被叫做有界缓冲区问题，问题描述：</p>
<ul>
<li>一个或多个生产者生产某种类型的数据放置在了缓冲区中。当缓冲区已满时，生产者不会继续向其中添加数据；</li>
<li>有消费者从缓冲区中取数据，每次取一项。当缓冲区为空时，消费者不会从中移走数据。</li>
<li>只能有一个生产者或者消费者对缓冲区进行操作；</li>
</ul>
<p>使用三个信号量，其中 mutex 用来解决互斥问题，empty 和 full 用来解决同步的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#define N <span class="number">100</span>;			<span class="comment">// 缓冲区的个数</span></span><br><span class="line">typedef <span class="type">int</span> semaphore;	<span class="comment">// 信号量是一种特殊的整型数据</span></span><br><span class="line"><span class="type">semaphore</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="number">1</span>;	<span class="comment">// 互斥信号量：控制对临界区的访问</span></span><br><span class="line"><span class="type">semaphore</span> <span class="variable">empty</span> <span class="operator">=</span> N;	<span class="comment">// 空缓冲区的个数</span></span><br><span class="line"><span class="type">semaphore</span> <span class="variable">full</span> <span class="operator">=</span> <span class="number">0</span>;		<span class="comment">// 满缓冲区的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">producer</span><span class="params">(<span class="keyword">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (True) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> produce_item();</span><br><span class="line">        p(&amp;empty);</span><br><span class="line">        p(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        v(&amp;mutex);</span><br><span class="line">        v(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (True) &#123;</span><br><span class="line">        p(&amp;full);</span><br><span class="line">        p(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> remove_item();</span><br><span class="line">        v(&amp;mutex);</span><br><span class="line">        v(&amp;empty);</span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能交换两个 P 操作的位置，假设交换消费者中的两个 P 操作，buffer 中为空。那么将先执行P(&amp;mutex) ，mutex&#x3D;0，再执行 P(&amp;full)，消费者会等待在 full 信号量的队列中。接着在消费者让出CPU 后，生产者进入 CPU 先执行 P(&amp;empty)，然后执行 P(&amp;mutex)，但是 mutex&#x3D;-1，生产者等待进入临界区。此时消费者等待生产者生产产品，生产者等待进入临界区，就会出现死锁问题。</li>
<li>两个 V 操作的的位置最好也不要交换，交换不会带来死锁问题，但是会扩大临界区的范围，这样子其他进程进入临界区的时间可能会延迟。同理，produce_item() 和 consume_item() 也不应该放入临界区中。</li>
</ul>
<p>互斥操作时，相同信号量的 PV 操作是在同一个进程中的。同步操作时，一个信号量的 PV 操作是分散在两个或多个进程中的，一个进程做 P 操作，另一个做 V 操作。</p>
<h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>问题描述：多个进程共享一个数据区，这些进程分为只读数据区中的数据的读者进程和只往数据区中写数据的写者进程。允许多个读者同时执行读操作，不允许多个写者同时操作，不允许读者、写者同时操作。在这里讨论读者优先的情况：<br>当读者进程执行：</p>
<ul>
<li>无其他读者、写者，该读者可以读；</li>
<li>若已有写者等，但有其他读者正在读，则该读者也可以读；</li>
<li>若有写者正在写，该读者	必须等；</li>
</ul>
<p>当写者进程执行：</p>
<ul>
<li>无其他读者、写者，该写者可以写；</li>
<li>如果有读者正在读，该写者等待；</li>
<li>如果有其他写者正在写，该写者等待；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">int</span> semaphore;</span><br><span class="line"><span class="type">semaphore</span> <span class="variable">count_mutex</span> <span class="operator">=</span> <span class="number">1</span>;	<span class="comment">// 多个进程可能同时修改count，所以对count加锁</span></span><br><span class="line"><span class="type">semaphore</span> <span class="variable">data_mutex</span> <span class="operator">=</span> <span class="number">1</span>;	<span class="comment">// 对读写的数据加锁</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 对数据进行读操作的进程数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        p(&amp;count_mutex);</span><br><span class="line">        count = count + <span class="number">1</span>;		</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) p(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        v(&amp;count_mutex);</span><br><span class="line">        </span><br><span class="line">        read();</span><br><span class="line">        </span><br><span class="line">        p(&amp;count_mutex);</span><br><span class="line">        count = count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) v(&amp;data_mutex); <span class="comment">// 最后一个读者需要对数据解锁，让写进程访问</span></span><br><span class="line">        v(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        p(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        v(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>因为信号量机制在程序编写的时候困难、易出错，所以在程序设计语言中引入了管程，是一种高级的同步机制。</p>
<p>管程是一种特殊的数据类型，其中包含了共享资源的数据结构及在该资源上的一组操作过程。进程只能通过调用管程中的过程来间接访问管程中的数据结构。</p>
<h3 id="互斥-x2F-同步"><a href="#互斥-x2F-同步" class="headerlink" title="互斥 &#x2F; 同步"></a>互斥 &#x2F; 同步</h3><ul>
<li>互斥：管程是互斥进入的，互斥性由编译器实现。</li>
<li>同步：管程中设置条件变量及等待&#x2F;唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待（此时，应该释放管程的使用权），也可以通过发送信号将等待在条件变量上的进程或线程唤醒。</li>
</ul>
<p>进程运行的过程中会出现多个进程同时出现在管程内（例如 P 唤醒了 Q），有三种解决方法：</p>
<ul>
<li><strong>HOARE管程：</strong>P 等待 Q 执行；</li>
<li><strong>MESA 管程：</strong>P 继续执行，Q 等待 P 执行结束；</li>
<li><strong>Hansen管程：</strong>规定唤醒操作为管程中最后一个可以执行的操作；</li>
</ul>
<h3 id="HOARE-管程"><a href="#HOARE-管程" class="headerlink" title="HOARE 管程"></a>HOARE 管程</h3><p>因为管程是互斥进入的，所以当一个进程试图进入一个被占用的管程时，需要在管程的入口等待队列等待。</p>
<p>如果进程 P 唤醒了进程 Q，则 P 等待 Q 执行；如果进程 Q 执行中又唤醒了进程 R，则 Q 等待 R 执行；如此反复，在管程内可能出现多个等待进程。所以在管程内设置了紧急等待队列，该队列的优先级高于入口等待队列。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2323967/1648968162658-7a7dba9f-0eb5-4118-875e-7323f2d2c072.png#clientId=u03303e20-ccbb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=u6dfcd002&margin=%5Bobject%20Object%5D&name=image.png&originHeight=274&originWidth=401&originalType=binary&ratio=1&rotation=0&showTitle=true&size=84158&status=done&style=stroke&taskId=u05ef408d-7913-49cd-976d-faf8f978974&title=HOARE%E7%AE%A1%E7%A8%8B&width=447.5" alt="image.png" title="HOARE管程"></p>
<h4 id="HOARE-管程中的条件变量"><a href="#HOARE-管程中的条件变量" class="headerlink" title="* HOARE 管程中的条件变量"></a>* HOARE 管程中的条件变量</h4><p>条件变量是在管程内部说明和使用的一种特殊类型的变量，对于条件变量可以执行 wait 和 signal 操作：</p>
<ul>
<li><strong>wait(c)：</strong>如果紧急等待队列为空，则唤醒队列中的第一个等待者；否则释放管程的互斥权，执行该操作的进程进入条件变量 c 链的末尾；</li>
<li><strong>signal(c)：</strong>如果 c 链为空，则相当于空操作，执行 signal 操作的进程继续执行；否则唤醒 c 链上的第一个等待者，执行 signal 操作的进程进入紧急等待队列的末尾；</li>
</ul>
<h4 id="用管程解决生产者-消费者问题"><a href="#用管程解决生产者-消费者问题" class="headerlink" title="* 用管程解决生产者-消费者问题"></a>* 用管程解决生产者-消费者问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">	condition full, empty; <span class="comment">// 条件变量</span></span><br><span class="line">    integer count;</span><br><span class="line">	</span><br><span class="line">	producer <span class="title function_">insert</span><span class="params">(item: integer)</span>;</span><br><span class="line">	begin</span><br><span class="line">    		<span class="keyword">if</span> count == N then <span class="title function_">wait</span><span class="params">(full)</span>; <span class="comment">// 如果产品数量为N，则生产者在条件变量full上等待</span></span><br><span class="line">			insert_item(item); count++;</span><br><span class="line">			<span class="keyword">if</span> count == <span class="number">1</span> then <span class="title function_">signal</span><span class="params">(empty)</span>; <span class="comment">// 如果产品数量为1，唤醒在条件变量empty中可能等待的消费者</span></span><br><span class="line">	end;</span><br><span class="line"></span><br><span class="line">	function remove: integer;</span><br><span class="line">	begin</span><br><span class="line">    		<span class="keyword">if</span> count == <span class="number">0</span> then <span class="title function_">wait</span><span class="params">(empty)</span>; <span class="comment">// 如果产品数量为0，则消费者在条件变量上empty上等待</span></span><br><span class="line">			remove = remove_item; count--;</span><br><span class="line">			<span class="keyword">if</span> count == N-<span class="number">1</span> then <span class="title function_">signal</span><span class="params">(full)</span>; <span class="comment">// 如果产品数量为N-1，唤醒在条件变量full中可能等待的生产者</span></span><br><span class="line">	end;</span><br><span class="line">	count:=<span class="number">0</span>;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">procedure producer</span><br><span class="line">begin</span><br><span class="line">		<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="type">begin</span></span><br><span class="line">        		<span class="variable">item</span> <span class="operator">=</span> produce_item;</span><br><span class="line">		end</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">procedure consumer;</span><br><span class="line">begin</span><br><span class="line">		<span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="type">begin</span></span><br><span class="line">        		<span class="variable">item</span> <span class="operator">=</span> ProducerConsumer.remove;</span><br><span class="line">				consume_item(item);</span><br><span class="line">		end</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h3 id="MESA-管程"><a href="#MESA-管程" class="headerlink" title="MESA 管程"></a>MESA 管程</h3><p>HOARE 管程有个缺点就是会有两次额外的进程切换，因此 MESA 管程将原本的 signal 操作变为 notify 操作：当一个正在管程中的进程执行 notify(x) 时，它使得 x 条件队列得到通知，发信号的进程继续执行，而位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行。</p>
<p>由于收到通知时并未执行，且对等待进程在 notify 之后何时运行没有任何限制，所以当进程真正被调度时，条件不一定成立，因而这个进程必须重新检查条件，也就是用 while 循环取代if语句。</p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><blockquote>
<p>IPC，InterProcess Communication，进程间通信，是指在不同的进程之间传播或交换信息。</p>
</blockquote>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通行，传输一些进程同步所需要的信息。</p>
<p>IPC 包含管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Stream等方式。其中 Socket 和 Stream 支持不同主机上的两个进程进行通信。 </p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>通常指的是无名管道，是 UNIX 系统 IPC 最古老的形式。</p>
<p>管道是通过调用 pipe 函数创建的，当一个管道建立时，它会创建两个文件描述符：fd[0] 为读而打开，fd[1] 为写而打开，要关闭管道只需要将这两个文件描述符关闭即可。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2323967/1648971085104-2b2db58f-a260-4e57-8e53-9069c4d4e495.png#clientId=u03303e20-ccbb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=222&id=udc9b00c0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=281&originWidth=513&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14489&status=done&style=stroke&taskId=u6421a3bf-31e4-439d-ab27-c929cb822a6&title=&width=405.5" alt="image.png"><br>单个进程中的管道几乎没有任何用处。所以，通常调用了 pipe 的进程接着调用 fork，这样就创建了父进程和子进程之间的 IPC 通道。若要数据流从父进程流向子进程，则关闭父进程的读端（fd[0]）与子进程的写端（fd[1]）；反之，则可以使数据流从子进程流向父进程。</p>
<p>特点：</p>
<ul>
<li>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</li>
<li>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</li>
</ul>
<h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>FIFO 也称为命名管道，它是一种文件类型，可以在无关的进程之间交换数据，与无名管道不同。</p>
<p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2323967/1648977479034-1db951e2-8385-4b50-b811-12b676d33d3a.png#clientId=u03303e20-ccbb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=278&id=u83261e30&margin=%5Bobject%20Object%5D&name=image.png&originHeight=444&originWidth=639&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24813&status=done&style=stroke&taskId=u9a83a20e-ea7b-440f-abca-7f91f97dfa1&title=&width=400.5" alt="image.png"></p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（队列 ID）来标识。</p>
<ul>
<li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</li>
<li>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</li>
<li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</li>
</ul>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存指两个或多个进程共享一个给定的存储区，因为数据不需要在进程之间复制，所以这是最快的一种 IPC。由于多个进程可以同时操作，所以信号量与共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</p>
<p>如下图所示，两个进程 1 和 2 都有各自的内存地址空间，在物理内存空间有一块共享内存，两个进程中都有一块内存空间映射到了同一块物理内存（即共享内存）。共享内存也包含了一个读者-写者问题：不能多个进程同时写入，但支持同时读取。假设进程1想往共享内存写数据，只需要往本地映射的内存空间写入数据，相当于是写入了共享内存。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2323967/1648977650439-44429571-d6cc-432f-9663-3a6c9f81ac8b.png#clientId=u03303e20-ccbb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=u815853fd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=522&originWidth=952&originalType=binary&ratio=1&rotation=0&showTitle=false&size=95780&status=done&style=none&taskId=ua926f561-4e33-48fc-b964-9d70b8cbb43&title=&width=476" alt="image.png"></p>
<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p>与其他的通信机制不同，它可以用于不同机器之间的进程通信。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.coursera.org/learn/os-pku/home/week/5">北京大学操作系统原理（Operating Systems）</a></li>
<li><a target="_blank" rel="noopener" href="http://hecenjie.cn/2019/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">操作系统原理-同步机制-水木今山</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html#_3-%E5%8C%BA%E5%88%AB">CS-Notes</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6951581796295262239">【操作系统】同步互斥机制（二）：管程与进程间通信机制（IPC）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8019b59b913a">操作系统-同步互斥机制2</a></li>
</ol>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/09/05/%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/">存储模型</a>
            
            
            <a class="next" rel="next" href="/2022/09/05/%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/">处理器调度</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Bruce Yao | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>